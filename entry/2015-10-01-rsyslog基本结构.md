---
layout: post
title: rsyslog基本结构
category: rsyslog
tags: [rsyslog]
---

### RSYSLOG基本结构

- Rsyslogd通过`rsyslog.conf`文件进行配置，标准存放路径为`/etc/rsyslog.conf`。当然这个路径可以通过命令行选项进行变更
- 注意配置都可以通过在线的[rsyslog配置工具](http://www.rsyslog.com/rsyslog-configuration-builder/)进行交互式的配置
- 所有的配置项必须在单独的行进行设置，并且需要以`$`开头
- 配置文件示例可以在[rsyslog wiki](http://wiki.rsyslog.com/index.php/Configuration_Samples)中找到。同时可以看一下[rsyslog配置片段](http://www.rsyslog.com/guides/)，这些都可以在真实的环境中进行配置
- 本文档还提供了一个示例配置文件，如果你不想看，请至少参考一下`rsyslog-example.conf`文件
- Rsyslogd在兼容标准syslogd方面做了很多努力和增强。当然，增强的那些功能是需要使用不同的配置语法的，rsyslogd可兼容标准的syslogd.conf配置文件，这对于从syslogd迁移到rsyslogd来说是很有用的。

### 基本结构

- 本节内容描述了rsyslog配置文件是如何工作的。rsyslog可以被看成一套日志和事务处理的工具，它可以被看做成一个数据流动过程中内置的基本处理框架，但是对于消息流，它使可以高度定制化的。在配置过程中，定制工作是通过自定义rsyslog对象来完成的

### 消息流和对象概览

- 消息是通过input模块进入rsyslog的，接着，他们会被传递到ruleset，即有很多规则应用的地方，当规则匹配，消息就会被应用到某个动作，也就是消息会被做一些处理，比如写入到文件，数据库或者继续被转发到远程主机等等

### 处理原则

- input将接收的消息传递到rulesets。如果并没有指定的ruleset与之绑定，则会使用默认的ruleset
- 默认的ruleset为：RSYSLOG_DefaultRuleset
- 用户可以定义额外的ruleset
- 每个ruleset会包含0个或多个规则。虽然允许ruleset中不包含任何规则，但是这并没有什么意义
- 一条规则包含一个过滤器和一个动作列表
- 过滤器主要是用来控制流量，并使用yes/no来做决定
- 如果过滤器被匹配（即过滤器`say 'yes'`），那么对应的动作列表就会被执行，未被匹配的话，则不做任何操作
- ruleset中的规则是按顺序从头到尾进行检查的，不相关ruleset中的rule不会生效
- 不论过滤器是否被匹配到，所有规则都会被检查。如果想要取消对某消息的处理，则”取消“动作必须显式执行。如果取消被执行，消息处理会立马结束而不去检查更多地规则
- 一个动作列表包含一个或多个动作
- 在动作列表中不会再出现过滤器
- 想在一个动作列表中设置多个动作，则必须在过滤器的位置加上一个`&`(ampersand）符号，并且`&`必须要紧接着前一个动作
- 动作包括动作本身（如":omusrmsg:"）和所有的定义动作的配置语句（如$Action... directives）
- 如果使用传统格式，动作配置语句必须在配置之前进行指定
- 某些配置指令会在被应用后自动关联到它之前的值，详情可参考命令文档。
- 一般来说，rsyslog v5是严重过时的版本，并且它原生的配置语法非常不友好。所以rsyslog项目强烈建议使用至少v7以上的版本，因为配置语法问题已经被解决，并且配置起来会很简单
- 传统的配置语句（以"$"开头）不会对RainerScript对象（如actions）造成影响

### 配置文件

- 在startup平台，rsyslog默认读取的配置文件为`rsyslog.conf`，这个配置文件中可能会包含对其他配置文件的引用
- 若不适用默认的配置文件，则可以在rsyslogd命令行中使用`-f <file>`来指定，这个功能通常会在一些启动脚本或类似的地方用到

### 配置语句类型(statement types)

- 当前,Rsyslog可以支持三种不同类型的配置语句
	- sysklogd - 这是一种简单陈旧的语句格式，很多地方可以找到教程，并且在很多简单地案例中非常有用，需要注意的是，这种类型的语句中一些结构已经不再被支持了，因为它们无法兼容一些新的功能，这方面内容会再兼容性文档中讲到
	- legacy rsyslog - 这是一种以"$"符开头的语句。它们可以用来配置和修改一些参数比如action的运行方式，这种格式只支持v6之前的rsyslog版本。注意一些插件和功能可能仍然只能用这种格式来实现
	- RainerScript - 最新的语句格式。在很多复杂的案例中，这种方式是最好切最精确的格式，接下来的文档中约定使用这种格式
- `rsyslog.conf`文件是由配置语句组成的。对于旧的语句类型（sysklogd & legacy rsyslog），行是很重要的概念，但对于RainerScript换行是无关紧要的，更重要的是，这意味着在新的语句类型中，动作和其他对象是可以根据用户需求使用跨行的方法进行分离的

### 推荐使用的语句类型

- 综上所述，RainerScript是推荐使用的语句类型，因为这种语句提供了简明易懂的方法来读取如何对消息流进行控制，同时可以很清晰了解哪些参数是活跃的，而且语句不会对其他配置文件（include files）产生副作用，这就使得它能够兼容legacy rsyslog语句
- 对于一些简单地事情，仍然推荐使用sysklogd语句类型，特别是在所有配置文件都包含这种”简单的事情“的情况下。一个典型的例子就是根据级别来将消息写入文件(或对消息进行转发)，在sysklogd语句中，可以这样配置：

```
mail.info /var/log/mail.log
mail.err @server.example.net
```

- 在简单的案例中，这种语句是无懈可击的，很多人都了解这种语法。其实在一些配置文件中，这种结构都很适用
- 根据经验，RainerScript配置语句通常被用于：
	- 配置参数（比如legacy statement中得Action...类型）
	- 配置更精确的消息流控制语句（比如多个动作应用到同一种条件下）
- 通常不建议使用rsyslog legacy的配置格式（以"$"开头），但是有些设置和模块还没有支持RainerScript就只能使用legacy语法了

### 解释信息（comments）

- 解释信息的两种写法
	- `#-Comments` - 以`#`开头，写在行尾
	- `C-style Comments` - 以`/*`开头，`*/`结尾，即C语言中的写法
- 这两种写法可以用来一次性写多行的解释信息。内嵌的解释信息是不支持的，但是`#-Comments`可以被写在`C-style`的解释信息中

### 处理顺序

- `rsyslog.conf`中得命令是从上到下一次执行的，所以，如果你停止了对某消息的处理，那么这行之后的命令就不会再被检查和执行了

### 流控制语句

- `if expr then ... else ...`- 条件语句
- `stop` - 停止处理当前消息
- `call` - 调用一个rulese（类似子程序调用）
- `continue` - 一个空操作（NOP）,很有用。比如在if语句的then部分
- 流控制也可以通过[过滤器条件](http://www.rsyslog.com/doc/master/configuration/filters.html)来实现

### 数据操作语句（Data Manipulation Statements）

- `set` - 设置一个用户变量
- `unset` - 删除之前设置的用户变量

### 输入（inputs）

- 每种输入都需要加载一个输入模块并且需要针对它定义一个监听器，详情可参考[rsyslog模块文档](http://www.rsyslog.com/doc/master/configuration/rsyslog_conf_modules.html)。一旦加载完毕，输入就会通过input()对象来定义

### 输出（outputs）

- 输出也被称为“动作”（actions），一小部分的动作会被预加载（比如“输出文件写入”就几乎被所有rsyslog.conf文件使用），其他的部分需要通过与输入类似的方法进行加载
- 每个动作都是通过`action(type="type" ...)`对象来调用的，type是强制的并且需要包含被嗲用的插件名（比如"omfile"或者"ommongodb"），可能还会有其他的一些参数存在。他们的类型和使用依赖于输出插件

### rulesets和rules

- rulesets和rules是rsyslog处理器的基本构成。简单来说，一个rule就是rsyslog该如何对一个特定的消息进行处理，通常，在rule之前会有一个过滤器（if语句），有可能会出现内嵌的复杂rules，就像一个编程语言
- rulesets是rules得容器，一个单独的ruleset可以包含很多rules，与编程语言相比，ruleset就像是一个程序。一个ruleset可以被绑定到（指派给）一个指定的输入，就像是如果有有一条消息是通过某种输入进来的，那么与这个输入绑定的ruleset就会被执行
- 对于ruleset有一个更详细的[文档](http://www.rsyslog.com/doc/master/concepts/multi_ruleset.html)
- 可以通过下面的例子对ruleset有一个快速地了解：

```
ruleset(name="rulesetname"){
    action(type="omfile" file="/path/to/file")
    action(type="..." ...)
    /* and so on... */
    }
```
