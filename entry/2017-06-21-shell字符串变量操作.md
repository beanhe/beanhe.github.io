---
layout: post
title: shell字符串变量操作
category: shell,linux
tags: [__beanhe,shell,linux]
---

### Shell变量操作

##### 以路径变量`destPath=/path/to/dest/file.name.txt`为例

##### 相比`awk`、`sed`等命令进行字符串的处理，Shell内部也提供了一些常用的处理方式，看一个简单测试：

```
ubuntu@hostname ~$ time for i in `seq 1000`;do echo ${destPath/#\//.} > /dev/null;done

real	0m0.024s
user	0m0.016s
sys	0m0.002s
ubuntu@hostname ~$ time for i in `seq 1000`;do echo ${destPath} | sed 's/\//./' > /dev/null;done

real	0m2.335s
user	0m0.228s
sys	0m2.321s
```

- 可以看出，都是替换变量值开头的`/`为`.`1000次，`Shell`内部的方式用时`0.002`秒，而`sed`命令则用了`2.321`秒，足足是`Shell`内置方法的`1100`多倍，所以掌握`Shell`内置的一些变量处理方法是绝对有必要的，以下是一些常见的`Shell`内置变量处理方法举例，简单分成了变量值定义相关、截取、替换以及变量值长度获取的方法

#### 变量定义相关

- 定义变量：`var_name=var_value`

```
var='value'
number=1
```

- 默认情况下，变量是可读写的，即重新赋值就可以直接改变变量的内容，如果要定义一个制度变量则在变量赋值完成后使用`readonly`命令即可

```
ubuntu@hostname: ~$ a=user1
ubuntu@hostname:~$ echo $a
user1
ubuntu@hostname:~$ readonly a
ubuntu@hostname:~$ a=user2
-bash: a: readonly variable
```

- 删除变量：直接使用`unset var_name`

```
ubuntu@hostname~$ b=test
ubuntu@hostname~$ echo $b
test
ubuntu@hostname~$ unset b
ubuntu@hostname~$ echo $b
<此处为空>
ubuntu@hostname~$
```

#### 变量值截取：`${var#*substring}`、`${var##*substring}`、`${var%%substring*}`、`${var%substring*}`、`${var:position}`、`${var:position:length}`、`${var:0-position}`、`${var:0-position:length}`

- `#*/`和`##*/`：以指定字符（此处为`/`)为分隔符，删除左边字符及分隔符，保留右边字符，区别是：
	-`${var#*substring}`：`#*`只删除第一次分割左边的内容和第一个分隔符，保留第一次分割右边的所有内容
	- `${var##*substring}`：`##*`则是只保留最后一次分割右边的内容，其余左边的部分全部删除
	- 例如以`/`和以`.`为分隔符

```
# beanhe @ BeandeMacBook-Pro in ~ [18:40:48]
$ echo ${destPath##*/}
file.name.txt  -----> 此处获得了文件名，相当于 basename $destPath

# beanhe @ BeandeMacBook-Pro in ~ [18:40:56]
$ echo ${destPath#*/}
path/to/dest/file.name.txt

# beanhe @ BeandeMacBook-Pro in ~ [18:59:28]
$ echo ${destPath##*.}
txt  -----> 此处获得了文件后缀名

# beanhe @ BeandeMacBook-Pro in ~ [18:59:51]
$ echo ${destPath#*.}
name.txt
```

- `%/*`和`%%/*`：与上面相反，以指定字符（此处为`/`）为分隔符，删除右边字符及分隔符，保留左边字符，区别是：
	- `${var%substring*}`：`%/*`只删除第一次分割右边的内容和第一个`/`，保留第一次分割左边的所有内容
	- `${var%%substring*}`：`%%/*`则是只保留最后一次分割左边的内容，其余右边的部分全部删除
	- 例如以`/`为分隔符

```
# beanhe @ BeandeMacBook-Pro in ~ [18:41:02]
$ echo ${destPath%%/*}
<此处为空>

# beanhe @ BeandeMacBook-Pro in ~ [18:41:16]
$ echo ${destPath%/*}
/path/to/dest  -----> 此处获得了文件所在完整目录，相当于 dirname $destPath
```

- `${var:position:length}`：左边开始计数，从指定顺序字符开始截取固定长度的字符串，如从左往右第14个字符开始往右截取9个字符：

```
# beanhe @ BeandeMacBook-Pro in ~ [19:06:28]
$ echo ${destPath:14:9}
file.name  ------> 此处获得了不带后缀的文件名
```

- `${var:position}`：左边开始计数，从左往右截取从指定顺序开始一直到结尾的字符串内容，如上例中如果要获取完整文件名，则可以使用：

```
# beanhe @ BeandeMacBook-Pro in ~ [19:06:52]
$ echo ${destPath:14}
file.name.txt  ----> 相当于 basename $destPath
```

- `${var:0-position:length}`：从右边指定字符开始从左往右截取指定长度的字符串，如从右边数第13个字符开始计数，截取右边9个字符的内容：

```
# beanhe @ BeandeMacBook-Pro in ~ [19:13:03]
$ echo ${destPath:0-13:9}
file.name  ----> 此处获得了不带后缀的文件名
```

- `${var:0-position}`：从右边指定字符开始截取至字符串末尾，如从右边数第3个字符开始，截取至末尾的内容：

```
# beanhe @ BeandeMacBook-Pro in ~ [19:13:07]
$ echo ${destPath:0-3}
txt   ---> 此处获得了文件后缀名
```

#### 变量值替换：`${var/substring/replacement}`、`${var//substring/replacement}`、`${var/#prefix/replacement}`、`${var/%suffix/replacement}`

- `${var/substring/replacement}`：从左往右替换第一次匹配的内容为指定内容，如替换第一个`/`为`.`（由于替换的分隔符也为`/`所有所有替换的对象中的`/`需要被转义，即`\/`）：

```
# beanhe @ BeandeMacBook-Pro in ~ [19:20:10]
$ echo ${destPath/\//.}
.path/to/dest/file.name.txt
```

- `${var//substring/replacement}`：从左往右替换所有匹配的内容为指定内容

```
# beanhe @ BeandeMacBook-Pro in ~ [19:24:23]
$ echo ${destPath//\//.}
.path.to.dest.file.name.txt
```

- `${var/#prefix/replacement}`：如果前缀为`prefix`则将其替换为`replacement`：

```
# beanhe @ BeandeMacBook-Pro in ~ [19:42:26]
$ echo ${destPath/#\//.}
.path/to/dest/file.name.txt
```

- `${var/%suffix/replacement}`：如果后缀为`suffix`则将其替换为`replacement`：

```
# beanhe @ BeandeMacBook-Pro in ~ [19:42:23]
$ echo ${destPath/%txt/exe}
/path/to/dest/file.name.exe
```

#### 获取变量值的长度：`${#var}`

```
# beanhe @ BeandeMacBook-Pro in ~ [19:27:28]
$ echo ${#destPath}
27
```