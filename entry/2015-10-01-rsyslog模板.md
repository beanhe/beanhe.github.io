---
layout: post
title: rsyslog模板
category: rsyslog
tags: [rsyslog]
---

### RSYSLOG模板

- 模板是rsyslog中一个很重要的功能，通过模板可以根据用户需求指定任意的格式，模板也可以被用来动态生成文件名。rsyslog中得每个输出都使用了一些模板，包括针对文件的，针对用户消息的等等。数据库的写入程序希望他的模板是一条合适的SQL语句，因此可以看到模板也是高度可定制的。可能你会问如果没有指定模板，这些工作该如何完成呢?因为模板兼容的syslogd格式是被硬编码成rsyslogd的，所以如果没有指定任何模板，我们会使用其中的硬编码模板的。通过在syslogd.c文件中搜索“template_”可以找到硬编码的部分
- 模板是通过template()声明来指定的，当然也可以通过传统的"$template"来声明，要注意的是，传统的方法将计划在未来的版本中移除，所以强烈建议新用户使用新的语法
- 【注】template的关键部分是rsyslog的属性，可通过[LINK](http://www.rsyslog.com/doc/master/configuration/properties.html)来了解rsyslog的一些可用属性

### template()声明

- tempalte()语句用来定义templates，注意这是一种静态声明，表示所有的模板都会在rsyslog读取配置文件的时候被定义，所以templates不会受到if语句或者嵌入配置的影响
- 基本的template声明结构如下：

```
template(parameters)
```

- 除了这种简单地语法之外，下面的list templates则是一种扩展的支持：

```
template(parameters) {list-descriptions}
```
- 每个template都有一个名字，一个参数类型用来指定template的类型。名称必须唯一，如果不唯一，则template的行动就无法预知。类型参数指定不同的template类型，通过使用不同的类型就可以用不同的方法来定义template的内容，template的类型不会影响输出插件的工作，所以从配置的角度来讲，合适的template类型会很好地匹配你的需求，一下是支持的类型：
	- list
	- subtree
	- string
	- plugin
- 类型的描述如下

### list

- 这种类型中，template是由一系列反复出现的内容和变量语句生成的，这些内容通过"{}"包含起来，这种类型一般用于已知输出结构的情况，比如ommongodb。不过，它也能够完美运行于文本输出的情况。建议在有复杂属性替换的情况下使用这种类型，因为在这种情况下，基于列表的template比简单基于字符串的template要更清晰
- list template包含tempalte头部（type="list"）和紧接着的用"{}"括起来的constant和property部分。正如其名所描述，constant语句用来对那些“反复出现”的文本进行描述，property则用来描述属性，对于property有多种可用的选项，大多数选项被用来提取部分的属性内容或者用来修改文本（比如将大写字母转换为小写字母）
- 为了便于理解，可以残夏西面的一个真实示例：

```
template(name="tpl1" type="list"){
    constant(value="Syslog MSG is: '")
    property(name="msg")
    constant(value="', ")
    property(name="timereported" dataFormat="rfc3339" caseConversion="lower")
    constant(value="\n")
    }
```
- 这个示例可能会被用于定位常见的文件输出

### 常量的声明（constant statement）

- 这部分介绍了一种指定常量文本的方法。常量主要用于基于文本的输出。例如，为文本输出新建一个复杂的template，那么template往往需要通过一个新行来结束，那么这个新行就可以通过常量来指定，以下是一个示例：

```
template(name="outfmt" type="list"){
    property(name="$!usr!msgnum")
    constant(value+"\n")
    }
```

- 下面是常量文本中可被识别的一系列转义字符的含义：
	- `\` - 单个反斜线
	- `\n` - 换行（Line Feed）
	- `\000`(三位八进制数) - 表示数字值对应的字符（如，\101代表字母“A”），注意三个数都是必须的，虽然八进制是被支持的，但是还是建议使用十六进制
	- `\xhh`(十六进制数) - 表示数字值对应的字符（如，\x41代表“A“），注意两个数都是必须给定的
- 【注】如果反斜线后跟了一个不支持的字符，那么这将会被当做一个威胁报错（threated as an error），所以这种情况会导致不可知的动作
- 为了在基于文本的输出和其他结构化输出中使用同样地template，在为结构化输出创建name/value树的时候，没有“outname”参数的常量（constant text）会被忽略掉。所以如果你希望提供一些诸如mongodb的常量的时候，就必须含有“outname”，如下：

```
template(name="outfmt" type="list"){
    property(name="$!usr!msgnum")
    constant(value="\n" outname="IWantThisInMyDB")
    }
```
- 常量声明的时候可以使用下面的参数：
	- `value` - 常量的值
	- `outname` - 结构化输出中的字段名

### property的声明

- property声明用于包含属性文本，它可以用于所有的属性。选项（options）则用来指定提取或修改属性的某些部分，对于property支持以下参数：
	- `name` - 要访问的属性名
	- `outname` - 结构化输出中得字段名
	- `dateformat` - 用于指定日期相关属性的日期格式
	- `caseconversion` - 将文本字母转换成大写或小写，即支持的value有"lower"和"upper"
	- `controlcharacters` - 指定如何处理控制字符，支持的value为“转义字符”（escape），“空格”（用一个空格来替换）和“drop”（从字符串中移除）
	- `securepath` - 在dynafile templates中用来创建pathnames
	- `format` - 指定字段格式，支持的格式有：
	- `csv` - 用于生成csv数据的时候
	- `json` - 没有字段头（field header）的json格式
	- `jsonf` - 完整的json字段
	- `jsonr` - 没有双反斜线，但可将其作为安全的json字段
	- `jsonfr` - "jsonf"和"jsonr"的结合格式
	- `position.from` - 从这个位置开始包含子字符串（1是第一个位置）
	- [position.to](http://korea.egosio.com/search/) - 一直到这个位置开始包含子字符串
	- `position.relativeToEnd` - from和to的位置与字符串的结尾有关（the from and to position is relative to the end of the string instead of the usual start of string），从rsyslog v7.3.10开始支持此功能
	- `field.number` - 包含此字段的匹配
	- `field.delimiter` - 字段提取的分隔符的十进制值
	- `regex.expression` - 使用的正则表达式
	- `regex.type` - 要么ERE，要么BRE
	- `regex.nomatchmode` - 如果没有匹配该怎么做
	- `regex.match` - 所使用的匹配
	- `regex.submatch` - 所使用的子匹配
	- `droplastLf` - 如果有一串换行符（LF）则丢弃
	- `mandatory` - 表示字段的强制性，如果设置为"on"，那么就算为空，这个字段也会在结构化输出的时候一直存在。如果设置为"off"（默认值），那么当为空得时候，这个字段就不会传给结构化输出。这个选项在支持动态结构的输出中很有用（比如ommongodb）
	- `spifno1stsp` - 用于处理RFC3164 template的专用选项

### 子树（subtree）

- 从rsyslog 7.1.4开始启用的内容。subtree主要用来生成基于完整（CEE）subtree的template。这种模板主要用于知道如何处理层级结构的输出，比如ommongodb，对于这种类型，参数subtree必须被指定以告知要使用哪个subtree。例如`template(name="tpl1" type="subtree" subtree="$1")`表示包含所有CEE数据，而`template(name="tpl2" type="subtree" subtree="$!usr!tpl2")则只包含以"$!usr!tpl2"`开头的subtree。使用这种模板的核心理念是，真实地数据是通过set和unset脚本语句预生成的，同时结果的结构会再模板内部被使用。如果一个完整的subtree需要被直接放到对象的根部（object's root），则必须使用这种类型。相对于其他所有的模板类型，只有subcontainers能够被生成。注意subtree类型同样可以用于基本文本的输出，如omfile。不过，这种情况下，你是无法指定常量的，因此就无法包含换行符。由此，对于文本输出使用subtree同样被用于做调试或者一些特殊的场合（比如文本将会被JSON解释器所解析）
- 用例 - subtree的典型用例：先创建一个自定义的subtree然后再template中使用，比如：

```
set $!usr!tpl2!msg = $msg;
set $!usr!tpl2!dataflow = fied($msg, 58, 2);
template(name="tpl2" type="subtree" subtree="$!usr!tpl2")
```
- 这里，我们假设$msg包含不同的字段，来自某字段的数据将会被提取出来并存储用以与message一起作为字段的内容

### 字符串(string)

- 这种类型与传统的template很相似。它包含一个强制的参数`string`，用来包含要使用的模板字符串，模板字符串是常量和replacement变量的混合字符串。这种变量来自于message或者当最后的字符串到达插件时候生成的动态内容。基于字符串的模板是制定文本内容的一种很好的方法，特别是当对于属性没有复杂操作的情况下，特别适用
- 以下是一个基于字符串的模板示例：

```
template(name="tpl3" type="string"
    string="%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\n"
    )
```

- 上例中，百分号之间的文本将会被rsyslog的`property replacer`所解释。在nutshell中，它包含了将要使用的属性以及格式化所需的选项和其他处理，这与`list`模板中的`property`对象的功能类似（实际上仅仅是使用不同的语言来描述同样地事情）
- 所有百分号外的内容都是常量，这上例中，在属性值中间主要含有一些空格，在字符串的最后，使用了一个转义字符。
- 转义字符允许指定那些无法打印的字符，这与C以及其他语言中得转义字符相似，他们是以一个反斜线引出并在其后跟上一个或多个字符来表示特定的字符，比如“\7”在US-ASCII中代表BEL（响铃），“\n”代表新行。总之与C和perl语言支持的相似，但会有一些限制

### 插件（plugin）

- 使用plugin类型的时候，模板是由一个插件（或者被称为"strgen"或者"string generator"）来生成。它的格式是固定的，就像他被编码时候一样。然而这种类型并不灵活，由于它提供了很高的性能（并不是说其他类型的模板很缓慢，而是指在那些对实时性要求很高的环境中），所以会被使用。在这种类型中，`plugin`参数必须被指定，并且要包含插件名用来识别它。注意在模板中，插件必须要被实现加载好，例如：

```
template(name="tpl4" type="plugin" plugin="mystrgen")
```

### 选项（options）

- 选项是可选的，注意不要混淆模板的选项和属性的选项-属性选项会被属性替换器（property replacer）处理并用于单个属性而非整个模板。模板选项是大小写敏感的，目前模板属性有：
	- `option.sql` - 用于为MySQL将字符串格式化为SQL语句，其中的单引号（'）和反斜线()会被对应的转义字符替换（即“\'”和“\”）。注意在MySQL配置中，必须禁用`NO_BACKSLASH_ESCAPES`模式（默认就是禁用的）
	- `option.stdsql` - 将字符串格式化为SQL语句以发送给表在哪混的sql服务器。这种方式会将字段中的单引号(')用两个单引号来替换(’‘)，如果MySQL配置文件中`NO_BACKSLASH_ESCAPES`设置为on那么就必须使用这个stdsql选项
	- `option.json` - 将字符串格式化为JSON形式，这种方式会讲字段中的单引号(')用两个单引号(’‘)来替换。
- 不管什么时候，绝对不要同时时候多个模板选项，因为会引起未知的故障和逻辑错误
- 当模板是用以写入数据库的时候，则必须指定要么为sql选项要么为stdsql选项，否则有可能出现SQL注入的问题。需要注意的是，由于在现实情况，有的厂商并不遵守标准的sql规则而引入自己的转义方法，所以一种选项并不能满足所有的工作，因此你必须确保你使用的是正确地格式。如果格式错误，仍然有可能遭遇sql注入的威胁。数据库写入程序会检查模板中存在的SQL选项，如果不存在，那么数据库写入操作就会被禁用，这也主要是为了防止由于你忘记配置sql选项而导致的SQL注入问题。SQL选项对于文件也很有用，特别是在出于性能考虑，你想要将文件导出到另外一台机器的数据库中得情况。对于其他的情况，如果没有特别需要，建议不要使用，因为这会带来一些处理时间上的开销，虽然不多，但是对于某些在这方面敏感的系统来说，这就显得尤为重要了
- 对于写入数据库动作来说，默认情况下使用的是sql选项，由于当前我们只支持MySQL并且sql选项也兼容了MySQL默认的配置，所以这就是个最佳选择了。当然如果你将`NO_BACKSLASH_ESCAPES`设置为`on`的话，则就需要使用stdsql选项以避免SQL注意的威胁：

template(name="TraditionalFormat" type="string"
    string="%timegenerated% %HOSTNAME% %syslogtag%%msg%\\n"
    )

### 示例

- 用以写入文件的标准模板

```
template(name="FileFormat" type="list"){
    property(name="timestamp" dateFormat="rfc3339")
    constant(value=" ")
    property(name="hostname")
    constant(value=" ")
    property(name="syslogtag")
    property(name="msg" spifno1stsp="on")
    property(name="msg" droplastlf="on")
    constant(value="\n")
    }
```

- 相同功能的字符串模板如下：

```
template(name="FileFormat" type="string"
    string= %TIMESTAMP% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\n"
    )
```

- 【注】字符串模板中string必须单独写一行

- 用以转发到远程主机的标准模板（RFC3164模式）

```
template(name="ForwardFormat" type="list"){
    constant(value="<")
    property(name="pri")
    constant(value=">")
    property(name="timestamp" dateFormat="rfc3339")
    constant(value=" ")
    property(name="hostname")
    constant(value=" ")
    property(name="syslogtag" position.from="1" position.to="32")
    property(name="msg" spifno1stsp="on")
    property(name="msg")
    }
```

- 等价的字符串模板为：

```
template(name="forwardFormat" type="string"
    string="<%PRI%>%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%"
    )
```

- 用以写入到MySQL数据库的标准模板

```
template(name="StdSQLformat" type="list" option.sql="on"){
    constant(value="insert into SystemEvents (Message, Fcility, FromHost, Priority, DevieReportedTime, ReceivedAt, InfoUnitID, SysLogTag)")
    constant(value=" values ('")
    property(name="msg")
    constant(value="', ")
    property(name="syslogfacility")
    constant(value=", '")
    property(name="hostname")
    constant(value="', ")
    property(name="syslogpriority")
    constant(value=", '")
    property(name="timereported" dateFormat="mysql")
    constant(value="', '")
    property(name="timegenerated" dateFormat="mysql")
    constant(value="', ")
    property(name="iut")
    constant(value=", '")
    property(name="syslogtag")
    constatn(value="')")
    }
```

- 等价的字符串模板为：

```
tempalte(name="stdSQLformat" type="string" option.sql="on"
    string="insert into SystemEvents (Message, Facility, FromHost, Priority, DeviceReportedTime, ReceivedAt, InfoUnitID, SysLogTage) values ('%msg%', %syslogfacility%, '%HOSTNAME%', %syslogpriority%, '%timereported:::date-mysql%', '%timegenerated:::date-mysql%', %iut%, '%syslogtag%')"
    )
```

- 【注】string行必须为单独的一行

### 为omfile创建动态文件名

- 模板可以用来动态生成文件名，例如，如果你想要将syslog中得消息按照不同的主机分别放到不同的文件，那么就可以按照如下方法定义模板：

```
template(name="DynFile" type="string" string="/var/log/system-%HOSTNAME%.log")
```

- 传统的写法为：

```
$template DynFile,"/var/log/system-%HOSTNAME%.log"
```

### 传统格式（legacy format）

- 在v6之前的syslog版本中，你需要使用`$template`语法来声明配置模板，这些模板提供了对基于string和基于plugin的支持，并且在v7版本中，传统语法仍然可用，不过，我们还是建议避免使用传统语法来书写配置文件。传统语法和当前最新的配置语句可以在配置文件中混合使用。传统语法格式如下：

```
$template name,param[,options]
```

- 其中`name`就是模板名，`param`是用来指定模板内容的参数，`options`用来设置模板选项

### 字符串（string）

- 对于字符串来说，在传统语法和当前语法中都是一回事，例如：

```
$template strtpl,"PRI: %pri%, MSG: %msg%\n"
```

- 注意list在传统语法中是不被支持的，所以就需要使用复杂的属性替换器（property replacer）来完成复杂的事情。

### 插件（plugin）

- 插件就是指"plugin"类型的模板命令，插件参数就是插件名，用一个等号连接，例如：

```
template plugintpl,=myplugin
```

### 预留的模板名（reserved template names）

- 以"RSYSLOG_"开头的模板名是位rsyslog预留使用的，自定义的模板不要使用这些名字，否则有可能产生冲突导致未知故障。下面就是一直预留共使用的系统模板
	- `RSYSLOG_TraditionalFileFormat` - 传统风格的使用不怎么精确的时间戳的默认日志文件格式
	- `RSYSLOG_FileFormat` - “现代风格”的日志文件格式，与TraditionalFileFormat类似，但是使用的是更高精度的时间戳和时区信息
	- `RSYSLOG_TraditionalForwardFormat` - 传统风格的转发格式，时间戳精度低，通常用于将日志消息转发给其他的syslogd或者低于3.12.5版本的rsyslogd
	- `RSYSLOG_SysklogdFileFormat` - sysklogd兼容的日志格式。如果使用选项`$SpaceLFOnReceive on，$EscapeControlCharactersOnReceive off`和`$DropTrailingLFOnReception off`，那么日志格式就会遵从sysklogd的日志格式
	- `RSYSLOG_ForwardFormat` - 类似传统的风格，但是有更高精度的时间戳和时区信息。建议在将日志消息转发给3.12.5或更高的rsyslog版本的时候使用
	- `RSYSLOG_SyslogProtocol23Format` - 在IETF的`internet-draft ietf-syslog-protocol-23`中指定的格式，可能会成为新的RFC日志标准格式。这种格式加入了一些改进。rsyslog的消息分析程序（message parser）可以读懂这种格式，所以它可以在最近版本的rsyslog中使用，对于不支持的syslog版本可能会直接拒绝这种格式，所以使用之前最好检查一下。【注】在最终的RFC标准出台的时候，格式可能不会发生改变，但也有可能会发生一些变化
	- `RSYSLOG_DebugFormat` - 一种特殊的用于调试property故障的格式，不要在生产环境或者远程转发的情况下使用这种格式

### 传统的基于string的模板示例

- 本示例中展示了一些在传统格式中使用的一些默认的模板，通常在v6之前的版本使用，当然这些格式现在也是支持的，不过，强烈建议在新模板中使用新的格式。【注】每个$template语句都需要一个单独的行，但是为了显示，可能会被浏览器拆成多行。行是由空行来分隔的，在传统格式中，换行很重要

```
$template FileFormat,"%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\n"
$template TraditionalFileFormat,"%TIMESTAMP% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\n"
$template ForwardFormat,"<%PRI%>%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%"
$template TraditionalForwardFormat,"<%PRI%>%TIMESTAMP% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%"
$template StdSQLFormat,"insert into SystemEvents (Message, Facility, FromHost, Priority, DeviceReportedTime, ReceivedAt, InfoUnitID, SyslogTag) values ('%msg%', %syslogfacility%, '%HOSTNAME%', %syslogpriority%, '%timereported:::date-mysql%', '%timegenerated:::date-mysql%', %iut%, '%syslogtag%')",SQL``
```

### 其他文档

- [如何绑定模板](http://www.rsyslog.com/how-to-bind-a-template/)
- [为消息添加BOM](http://www.rsyslog.com/adding-the-bom-to-a-message/)
- [如何根据发送设备主机名分离日志文件](http://www.rsyslog.com/article60/)
